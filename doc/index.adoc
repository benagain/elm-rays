:source-highlighter: highlightjs
:icons: font
:docinfo1: 

= Mobile Elm Rays

[.lead]
Kris Jenkins wrote a raycaster in Elm. I put it in a mobile app.

== First, take your rays

In the Elm-Weekly newsletter a couple of weeks ago I stumbled across a cool raycasting project.  
The raycaster itself is about two pages of fairly easy to understand Elm code, you should https://github.com/krisajenkins/elm-rays/blob/master/src/Raycasting.elm[check it out].

As I've done a fair amount of work with cross-platform c++ mobile apps over the years, and still ocassionally write some Ionic based ones for work, I thought it would be fun to see how hard it is to write an app using Elm.  
By which I mean completely steal somebody else's code and simply make it run inside a https://cordova.apache.org/[Cordova] project.
Standing on the shoulder of giants and all that.

It turns out to be pretty easy.  
Essentially you create an empty Cordova project, find some code to plagiarise, hook up an elm compiler in the Cordova build process, load the generated javascript in the app, tie up a couple of loose ends and voila.

pass:[<a class="github-button" href="https://github.com/benagain/elm-rays-cordova/tree/cordova" data-style="mega" >View on Github</a>]

== Cordova

Easy.

[source, bash]
----
cordova create elm-rays-cordova hack.benagain.mobileelmrays \
        MobileElmRays --template phonegap-template-blank
----

== Elm-make

Cordova will run custom scripts at various points along the process if you tell it to.  There are 
https://cordova.apache.org/docs/en/latest/guide/appdev/hooks/[quite a few] places to choose from.  `before_prepare` will make
sure the compiler is run whenever you `cordova build` or `cordova run`.  Just add it to your Cordova `config.xml`

[source, xml]
----
<hook type="before_prepare" src="hooks/make-elm.js" />
----

And then make the script compile [line-through]#your# Kris' Elm files

[[app-listing]]
[source, javascript]
.hooks/make-elm.js
----
module.exports = function(context) {

    var Q = context.requireCordovaModule('q');
    var deferral = new Q.defer();
    var compile = require("node-elm-compiler").compile;

    compile(["./src/Main.elm"], {           // <1>
        output: "www/js/elm-main.js"        
    })
    .on('close', function(exitCode) {
        if(exitCode == 0)
            deferral.resolve(exitCode);     // <2>
        else
            deferral.reject(new Error("Elm compilation"));
    });

    return deferral.promise;
}
----
<1> We only specify the single Main.elm file, everything else Just Works(TM)
<2> `node-elm-compiler` uses asynchronous spawn.  Luckily Cordova support promises in its custom scripts.  

== HTML App

Cordova essentially wraps your HTML site inside a native app that is really only a WebView.
It also provides Cordova Plugins to give you access to device features such as the camera, contact list, etc.
A number of projects have built on top of this to let you write http://ionicframework.com/[Angular] or http://reapp.io/[React] based apps quite easily.
We ignore all of that and simply embed the Elm app as per the https://guide.elm-lang.org/interop/javascript.html#step-1-embed-in-html[guide]. 

[[app-listing]]
[source, html]
.www/index.html
----
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, 
                                   user-scalable=no, width=device-width">
    <link rel="stylesheet" type="text/css" href="css/index.css">
    <title>ElmRayCast</title>
  </head>
  <body id="elm-main" >
    <script type="text/javascript" src="cordova.js"></script> 
    <script type="text/javascript" src="js/elm-main.js"></script> <!--1-->
    <script>
      var node = document.getElementById('elm-main');
      var app = Elm.Main.embed(node);
    </script> <!--2-->
  </body>
</html>  
----
<1> This is the generated output from elm-make.
<2> Straight out of the Elm guide.

_And that's it!_

[source, bash]
----
cordova run android --
----

You have an Elm app running you your phone.  
Just think about how much work people have put in so we could do virtually nothing.

There are a couple of niggles though.  The ray traced world is either a tiny part of the device's screen, or doesn't quite fit - depending on the device.  Also, the HTML links to Kris' github don't work.  Let's fix them.

== Fit to screen

We're actually going to modify some Elm code here!  
The original rectangle walls were hard-coded to 600x600, we need to figure out what the actual size is and recalculate the wall positions.  The window size can't be a pure function - browsers can be resized after all - so asking Elm for the window size is a `Cmd`, and we need to add a new `Msg` to handle the response.

Full diff: https://github.com/benagain/elm-rays-cordova/commit/295b5616b5578d6980eb2a786e90edf4e8ff692e[on Github icon:github[]]

[source, elm]
.src/Types.elm
----
type Msg
    = Mouse Mouse.Position
    | Resize Window.Size
----

[source, elm]
.src/State.elm
----
initialCmd =
    Task.perform 
        (\_ -> Resize (Window.Size 100 100))
        (\size -> Resize size)
        Window.size                 


update msg model =
    case msg of
        ...

        Resize size ->
            ( { model | display = modelForSize size }
            , Cmd.none
            )        


subscriptions _ =
    Sub.batch
        [ Mouse.moves Mouse
        , Window.resizes Resize
        ]            
----

We change the `initialCmd` from `Cmd.none` to a task that asks for the window size using our new `Resize` message.
If the task fails we simply set the display to a 100x100 square.
The `update` function handles the `Resize` by calculating a new set of walls. 
Whilst we're at it we also subscribe to the `Window.resizes` subscription, so when the device is rotated we resize to fit the new orientation.

